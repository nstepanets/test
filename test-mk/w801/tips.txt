Некоторые заметки по поводу SDK


1) О Времени

------------
u32 current_tick = tls_os_get_time();  -  время после старта OS в tick-ах 

переменная const unsigned int HZ - сколько tick в 1 секунде
 она тут константа, задана в конфигах, равно 500

u32 (uint32_t), это число 4 294 967 295 
 делим на 500, получается через 8 589 934 секунд, переменная обнулиться (переполнение) и по новой,
 это 143 165 минут, или 2 386 часов, или 99 дней... 

------------

если переводить в millis (я про Ардуино), то за 1 тик будет 2 миллесекунды, 
и для возвращаемого значения uint32_t в миллисекундах, это будет означять переполнение примерно через 50 дней...

функция millis будет выглядеть так:

#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

static uint32_t millis (void)
{
  uint32_t cur = tls_os_get_time ();
  if (cur > (UINT32_MAX / (1000 / HZ)))
    cur -= (UINT32_MAX / (1000 / HZ));
  return cur * (1000 / HZ);
};

------------

задержку в миллесекундах, можно сделать так
static void delay(u32 ms)
 {                                                      
 u32 tick = ms / (1000/HZ); // перевод ms в tick

 //ну, и если нужно, чтоб не менее прошло времени, в основном так и необходимо, 
 // то в данном случае в большую сторону сделаем
 if(ms> (tick * (1000/HZ)) ) tick++; 

 tls_os_time_delay(tick);
 };

------------

для реализации тиков, один за 2 миллисикунды, 
используеться прервываение от CORET (System Tick Timer) таймер ядра?

таймер работает выставленной на частоте процессара
у него 2 значения
 csi_coret_get_value() - текущее значение CORET, меняеться в сторону уменьшения
  при достижении нуля, возникает прерываение, и загрузка текущего значения из переменой 
 csi_coret_get_load() - настраевает OS при смене частоты процессора

значение load от частоты (load=clk_Hz/500-1):
240MHz load=479999
160MHz load=319999
80MHz  load=159999
40MHz  load=79999
2MHz   load=3999

если частоту в герцах поделить на значение load, 
то это и будет 500 герц (т.е. период 2 милисекунды)

------------

2) CPU:xt804 - little-endiann 

------------

3) printf("---> GetHeap:%d\n",tls_mem_get_avail_heapsize());

------------

4) в FreeRTOS
 #define USER_APP_TASK_PRIO 31 // меньше цифра, больше приоретет! 
это так для tls_os_task_create будет (там делается configMAX_PRIORITIES - prio ) 
где prio  -  the task's priority.  
 #define configMAX_PRIORITIES		(63)
 A unique priority MUST be assigned to each task and the lower the number, the higher the priority.
 Каждой задаче ДОЛЖЕН быть назначен уникальный приоритет, и чем меньше его число, тем выше приоритет.

------------



