project

board HLK-W801-KIT-V1.1 + u8g2 + st7920 + spi

Видео
https://youtu.be/ZmhRPNjVMo0

исходники u8g2, взяты с сайта https://github.com/olikraus/u8g2

пример адаптации взят из https://github.com/RIOT-OS/RIOT, (хотя можно было взять из LuatOS, к примеру)

~~~
в Makefile директории /app

добавлено

CFLAGS += -DU8X8_WITH_USER_PTR
CFLAGS += -DMODULE_PERIPH_SPI

INCLUDES += -I ./u8g2
~~~


~~~

в Makefile директории .

добавлено

    $(TOP_DIR)/app/u8g2 
    $(TOP_DIR)/app/libu8g2$(LIB_EXT) 

~~~





дисплей
 LCD12864 на контроллере ST7920
~~~
Разрешение экрана  - 128x64
Напряжение питания - 2.7-5.5 В
Количество выводов - 20
Интерфейсы доступа - параллельный (8/4 бит), последовательный
Возможность записи собственных символов для вывода на дисплей (в режиме вывода символов ASCII)
~~~



соеденить по схеме:
~~~
connect to
st7920      W801 descreption
------      ---- ------------------------------------------------------
4 CS(RS)    PB21 (PB14, не подходит)
                 (Serial mode: Chip select.
				1: chip enabled;
				0: chip disabled.
				When chip is disabled, SID and SCLK
				should be set as “H” or “L”. Transcient
				of SID and SCLK is not allowed.)
                 RS — (CS) Начало/окончание передачи данных (1 — начало, 0 — окончание)
          
6 SCLK(E)   PB15 (Serial Mode: Serial clock.)
                  E — (SCLK) Строб
 
5 SID(RW)   PB17 (Serial Mode: Sserial data input.)
                 RW — (SID) Шина данных
 

15 PSB      GND. (0: serial mode st7920)
                 PSB — Определяет какой протокол передачи данных будет использоваться ( 1 — 8/4 бит шина, 0 — SPI)

17 RST      PB22 Reset
 
19 BLA      3.3v (Backlight positive supply)
                 Анод подсветки (+), 
                 можно подключить через подстроечный резистор 10 ком - регулировать яркость

20 BLK      GND  (Backlight Negative supply)
                 Катод подсветки (-)

3 V0        3.3v Настройка контрастности
                 можно подключить через подстроечный резистор 10 ком - регулировать контрасность
                 а можно оставить свободным, т.к. с обратной стороны имеется потенциометр для настройки контраста.

2 VCC       5v (3.3 вольт, почему-то не сработало)
1 GND       GND
~~~







сборка:
~~~
делал по инструкциям из этого проекта https://github.com/droppingy/W801_SDK-linux
   у меня Linux Fedora 33 x86_64, думаю для всех Linux x86_64 подойдет

1) сначала, один раз, ставим утилиты для сборки c-sky (архитектура w806, w801 мк)
   благодаря пользователю droppingy это очень просто!  

$ sudo git clone https://github.com/droppingy/hlk-w80x-toolchain.git /opt/w80x-tools

   так чтобы в итоге получилось /opt/w80x-tools/bin
   это чтоб в menuconfig не переделывать, такой там путь по умолчанию
   (еще, в этом мануале https://github.com/IOsetting/wm-sdk-w806, есть ссылки как получить данный Toolchain на другие архитектуры, типа i386)

2) далее качаем SDK

    перемещаемся в домашнюю директорию
 
$ cd ~

    делаем директорию для проекта

$ mkdir w801

$ cd w801  

$ git clone https://github.com/droppingy/W801_SDK-linux.git

3) далее, собираем приложение

$ cd W801_SDK-linux

     если тут запустить make, то собирается демо приложение которое идет вместе с SDK, об этом я писал кратко в https://github.com/nvv13/test/tree/main/test-mk/w801 
     но мы хотим собрать другой проект
     для этого удаляем, лишние директории, 
      где app demo - директории с демо приложением
          bin - директория где в результате будет собранное приложение, создастся заново в процессе сборки

$ rm -R app demo bin

     делаем директорию для приложения

$ mkdir app

     и, в данном случае, качаем файлики приложения, 
     для примера, возьмем отсюда https://github.com/nvv13/test/tree/main/test-mk/w801/sdk-prj/02_task_blink
     но, принцип тот же самый и для других...(если нужно много файлов, то можно воспользоваться утилитой https://downgit.github.io/)

$ cd app

$ wget https://github.com/nvv13/test/raw/main/test-mk/w801/sdk-prj/02_task_blink/app/Makefile

$ wget https://github.com/nvv13/test/raw/main/test-mk/w801/sdk-prj/02_task_blink/app/main.c

     возвращаемся в директорию SDK
$ cd ..

     заменяем головной wget Makefile на наш (удалено обращение к директории demo)

$ rm Makefile

$ wget https://github.com/nvv13/test/raw/main/test-mk/w801/sdk-prj/02_task_blink/Makefile


     перед сборкой, очистить проект, иногда надо
$ make distclean


    сборка
$ make 


    перед прошивкой, стереть флэш в микроконтроллере, иногда надо, !когда, допустим был проект с wifi, а стал без него!
$ make erase

    записать прошивку
$ make flash

    Всё!


~~~






  далее подцепляемся к платке, если интересует вывод на консоль

$ picocom --echo -b 115200 /dev/ttyUSB0

  после подсоединения платка "висит", это из за сигнала RTS (про это есть обьяснение в статье https://www.cnblogs.com/milton/p/15621540.html)
  поэтому делаем CTRL + A + G   - это комманда picocom - RTS down, (нажимать надо достаточно быстро, (одновременно, но сначала CTRL))
  и пользуемся ...
          выход из picocom - CTRL + A + Q  (это выход без сброса порта (Skipping tty reset...))




~~~
PS:
исходники драйвера u8g2 https://github.com/olikraus/u8g2


статья про протокол https://habr.com/ru/post/213459/
 Режим SPI
SID это контакт передачи данных, на дисплее он же RW
SCLK – это линия строб, на дисплее он же E
CS – это начала/окончания передачи данных, на дисплее он же RS

В SPI режиме передача одной команды или 1 байта данных происходит при передачи 24 бит
 Протокол передачи данных таков:
Устанавливаем высокий уровень CS
 Передаем 5 единицы подряд - биты синхр             1-5
 Передаем 1 бит RW – чтения или запись              6
 Передаем 1 бит RS – Команда или данные             7
 Передаем 0                                         8
 Передаем 4 бита старшей половины байта данных      9-12
 Передаем 4 нуля                                    13-16
 Передаем 4 бита младшей половины байта данных      17-20
 Передаем 4 нуля подряд                             21-24
Устанавливаем низкий уровень CS

На этом передача одного байта завершена.

После каждого переданного бита делается строб, то есть:
 Задержка 1 мкс.
 Устанавливаем высокий уровень SCLK
 Задержка 1 мкс.
 Устанавливаем низкий уровень SCLK
 Задержка 1 мкс.

~~~






