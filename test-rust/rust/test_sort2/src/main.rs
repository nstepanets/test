mod my {
    // для того, чтобы использовать private функции, применяем mod

    use rand::prelude::*;

    #[derive(Debug)]
    pub struct Listopad {
        list: [i32; 30], // массив i32
    }

    impl Listopad {
        fn rand(&mut self) {
            for x in &mut self.list {
                *x = random();
            }
        }

        pub fn new_rand() -> Listopad {
            let mut new1 = Listopad { list: [0; 30] };
            new1.rand();
            new1
        }

        //---- Проверка упорядоченности массива
        pub fn is_sorted(&mut self) -> bool {
            for i in 0..self.list.len() - 1 {
                if self.list[i] > self.list[i + 1] {
                    return false;
                };
            }
            return true;
        }

        /*
        Сортировка методом пузырька

        Задача
        При работе с массивами данных не редко возникает задача их сортировки по возрастанию или убыванию, т.е. упорядочивания. Это значит, что элементы того же массива нужно расположить строго по порядку. Например, в случае сортировки по возрастанию предшествующий элемент должен быть меньше последующего (или равен ему).

        Решение
        Существует множество методов сортировки. Одни из них являются более эффективными, другие – проще для понимания. Достаточно простой для понимания является сортировкаметодом пузырька, который также называют методом простого обмена. В чем же он заключается, и почему у него такое странное название: "метод пузырька"?

        Как известно воздух легче воды, поэтому пузырьки воздуха всплывают. Это просто аналогия. В сортировке методом пузырька по возрастанию более легкие (с меньшим значением) элементы постепенно "всплывают" в начало массива, а более тяжелые друг за другом опускаются на дно (в конец массива).

        Алгоритм и особенности этой сортировки таковы:
         При первом проходе по массиву элементы попарно сравниваются между собой: первый со вторым, затем второй с третьим, следом третий с четвертым и т.д. Если предшествующий элемент оказывается больше последующего, то их меняют местами.
         Не трудно догадаться, что постепенно самое большое число оказывается последним. Остальная часть массива остается не отсортированной, хотя некоторое перемещение элементов с меньшим значением в начало массива наблюдается.
         При втором проходе незачем сравнивать последний элемент с предпоследним. Последний элемент уже стоит на своем месте. Значит, число сравнений будет на одно меньше.
         На третьем проходе уже не надо сравнивать предпоследний и третий элемент с конца. Поэтому число сравнений будет на два меньше, чем при первом проходе.
         В конце концов, при проходе по массиву, когда остаются только два элемента, которые надо сравнить, выполняется только одно сравнение.
         После этого первый элемент не с чем сравнивать, и, следовательно, последний проход по массиву не нужен. Другими словами, количество проходов по массиву равно m-1, где m – это количество элементов массива.
         Количество сравнений в каждом проходе равно m-i, где i – это номер прохода по массиву (первый, второй, третий и т.д.).
         При обмене элементов массива обычно используется "буферная" (третья) переменная, куда временно помещается значение одного из элементов.
        */
        pub fn sort(&mut self) {
            for i_pos in 0..self.list.len() - 1 {
                for i in 0..self.list.len() - i_pos - 1 {
                    if self.list[i] > self.list[i + 1] {
                        let val = self.list[i + 1];
                        self.list[i + 1] = self.list[i];
                        self.list[i] = val;
                    }
                }
            }
        }
    }
}

fn main() {
    // 1) создать мессив с произвольными данными
    let mut a1 = my::Listopad::new_rand();

    // 2) выводим
    println!("a1 равен {:#?}", a1);

    // 3) сортируем
    a1.sort();

    // 4) выводим, все
    println!("a1.sort() равен {:#?}", a1);

    // 5) проверка, отсортировано ли
    println!("a1.is_sorted() равен {:#?}", a1.is_sorted());
}
